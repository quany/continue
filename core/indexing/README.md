# 索引

“继续”使用标记系统以及内容寻址来确保不需要将任何内容编入索引两次。当您更改分支时，Continue 只会重新索引新修改的文件，并且我们还没有副本。只需实现“CodebaseIndex”类，该系统就可以在许多不同的“工件”中使用。

_artifact_：通过索引生成然后保存以备后用的内容（例如嵌入、全文搜索索引或每个文件中的顶级代码片段表）

_cacheKey_：一个键，用于确定是否可以将两个文件视为相同文件以避免重新编制索引（此时始终对文件内容进行哈希处理）

_'CodebaseIndex'_：一个类，可以轻松使用索引系统来帮助您生成新的工件

索引过程执行以下操作：

1. 检查存储库中所有文件的修改时间戳（这可能看起来很极端，但检查时间戳比实际读取文件快得多。Git 也做同样的事情。
2.将这些文件与上次索引每个文件以获取要“添加”或“删除”的文件列表的“目录”（存储在SQLite中）进行比较。如果文件存在于存储库中但不存在于目录中，那么我们必须“添加”该文件。如果它存在于目录中但不存在于存储库中，我们必须“删除”该文件。如果它存在于两者中，并且在上次索引后被修改，那么我们必须更新文件。在这种情况下，我们还将它添加到“添加”列表中。
3. 对于每个要“添加”的文件，检查它是否在另一个分支上索引。在这里，我们使用一个 SQLite 表作为索引文件的缓存。如果我们在此表中找到具有相同 cacheKey 的文件的条目，那么我们只需要为当前分支的此条目添加一个标签 （“addTag”）。否则，我们必须“计算”工件。
4. 对于“删除”中的每个文件，检查它是否在另一个分支上建立了索引。如果我们只找到一个具有相同 cacheKey 的条目（大概这应该是当前分支的条目，或者出了点问题），那么应该删除这个条目，并且不会再有需要该工件的分支，所以我们要“删除”它。如果此工件上有多个标签，那么我们应该删除此分支的标签（“removeTag”）。
5. 在计算了这四个文件列表（“compute”、“delete”、“addTag”、“removeTag”）之后，我们将它们传递给“CodebaseIndex”，以便它可以更新它可能具有的任何特定于索引的存储。他们中的许多人使用 SQLite 和/或 LanceDB。“CodebaseIndex”实现了一个名为“update”的方法，该方法接受四个列表，并在迭代列表时生成进度更新。这些进度更新用于正式将文件标记为已编入索引，这样，如果扩展在索引过程中关闭，我们就不会错误地记录进度。

## 现有 'CodebaseIndex'es

如果要使用所有索引，则必须由 ['indexCodebase.ts']（./indexCodebase.ts） 中的“getIndexesToBuild”返回。

“CodeSnippetsCodebaseIndex”：使用树保姆查询来获取每个文件中的函数、类和其他顶级代码对象的列表
“FullTextSearchCodebaseIndex”：使用 SQLite FTS5 创建全文搜索索引
“ChunkCodebaseIndex”：按代码结构递归方式对文件进行分块，用于其他嵌入提供程序，如“LanceDbCodebaseIndex”
'LanceDbCodebaseIndex'：计算每个区块的嵌入，并将它们添加到LanceDB向量数据库中，元数据将进入SQLite

## 已知问题：

- 'FullTextSearchCodebaseIndex' 不区分标签（分支、存储库），因此结果可能来自任何分支/存储库。LanceDB 通过为每个标签创建单独的表来实现这一点（参见“tableNameForTag”）。块索引使用第二个表执行此操作